// Generated by CoffeeScript 1.12.2
var createIndex, detectTransactionExamples, traverse,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  hasProp = {}.hasOwnProperty;

traverse = require('traverse');

detectTransactionExamples = function(transition) {
  var example, index, j, len, ref, state, transaction, type;
  index = createIndex(transition);
  if (!index.length) {
    if (transition.attributes == null) {
      transition.attributes = {};
    }
    transition.attributes.examples = 0;
    return;
  }
  example = 1;
  state = 'req';
  for (j = 0, len = index.length; j < len; j++) {
    ref = index[j], type = ref.type, transaction = ref.transaction;
    if (type === 'httpRequest') {
      if (state === 'res') {
        example += 1;
      }
      state = 'req';
    } else {
      state = 'res';
    }
    if (transaction.attributes == null) {
      transaction.attributes = {};
    }
    transaction.attributes.example = example;
  }
  if (transition.attributes == null) {
    transition.attributes = {};
  }
  transition.attributes.examples = example;
};

createIndex = function(transition) {
  var entry, index, key, mapping, traversal;
  mapping = {};
  traversal = traverse(transition);
  traversal.forEach(function(node) {
    var charBlock, entry, i, j, key, parentNode, path, positions, ref;
    if ((node != null ? node.element : void 0) !== 'sourceMap') {
      return;
    }
    if (indexOf.call(this.path, 'method') >= 0) {
      return;
    }
    key = null;
    entry = {};
    for (i = j = 0, ref = this.path.length; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
      path = this.path.slice(0, +i + 1 || 9e9);
      parentNode = traversal.get(path);
      switch (parentNode.element) {
        case 'httpRequest':
        case 'httpResponse':
          key = path.join('.');
          entry.type = parentNode.element;
          break;
        case 'httpTransaction':
          entry.transaction = parentNode;
      }
    }
    if (!(key && entry.type && entry.transaction)) {
      return;
    }
    positions = (function() {
      var k, len, ref1, results;
      ref1 = node.content;
      results = [];
      for (k = 0, len = ref1.length; k < len; k++) {
        charBlock = ref1[k];
        results.push(charBlock[0]);
      }
      return results;
    })();
    if (mapping[key]) {
      positions.push(mapping[key].position);
    } else {
      if (mapping[key] == null) {
        mapping[key] = entry;
      }
    }
    mapping[key].position = Math.min.apply(null, positions);
  });
  index = (function() {
    var results;
    results = [];
    for (key in mapping) {
      if (!hasProp.call(mapping, key)) continue;
      entry = mapping[key];
      results.push(entry);
    }
    return results;
  })();
  index.sort(function(entry1, entry2) {
    return entry1.position - entry2.position;
  });
  return index;
};

module.exports = detectTransactionExamples;
