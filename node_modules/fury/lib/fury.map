{"version":3,"sources":["src/fury.js"],"names":[],"mappings":"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","file":"src/fury.js","sourcesContent":["import minimModule from 'minim';\nimport minimParseResult from 'minim-parse-result';\n\nconst minim = minimModule.namespace()\n  .use(minimParseResult);\n\n/*\n * Find an adapter by a given media type and method name, which should be\n * either `parse` or `serialize`. If no adapter is found, then\n * undefined is returned.\n */\nfunction findAdapter(adapters, mediaType, method) {\n  for (let i = 0; i < adapters.length; i++) {\n    if (adapters[i].mediaTypes.indexOf(mediaType) !== -1 && adapters[i][method]) {\n      return adapters[i];\n    }\n  }\n}\n\nclass Fury {\n  constructor() {\n    this.adapters = [];\n  }\n\n  /*\n   * Register to use an adapter with this Fury instance.\n   */\n  use(adapter) {\n    this.adapters.push(adapter);\n    return this;\n  }\n\n  /*\n   * Load serialized refract elements into Javascript objects.\n   */\n  load(elements) {\n    return minim.fromRefract(elements);\n  }\n\n  findAdapter(source, mediaType, method) {\n    let adapter;\n\n    if (mediaType) {\n      adapter = findAdapter(this.adapters, mediaType, method);\n    } else {\n      for (let i = 0; i < this.adapters.length; i++) {\n        const current = this.adapters[i];\n        if (current.detect && current.detect(source) && current[method]) {\n          adapter = this.adapters[i];\n          break;\n        }\n      }\n    }\n\n    return adapter;\n  }\n\n  validate({source, mediaType, adapterOptions}, done) {\n    const adapter = this.findAdapter(source, mediaType, 'validate');\n\n    if (!adapter) {\n      return this.parse({source, mediaType, adapterOptions}, (err, result) => {\n        if (result && result.annotations.length > 0) {\n          const {ParseResult} = minim.elements;\n          const parseResult = new ParseResult(result.annotations);\n          done(err, parseResult);\n        } else {\n          done(err, null);\n        }\n      });\n    }\n\n    let options = {minim, source};\n\n    if (adapterOptions) {\n      options = Object.assign(options, adapterOptions);\n    }\n\n    adapter.validate(options, (err, elements) => {\n      if (!elements || elements instanceof minim.BaseElement) {\n        done(err, elements);\n      } else {\n        done(err, this.load(elements));\n      }\n    });\n  }\n\n  /*\n   * Parse an input document into Javascript objects. This method uses\n   * the registered adapters to automatically detect the input format,\n   * then uses the adapter to convert into refract elements and loads\n   * these into objects.\n   */\n  parse({source, mediaType, generateSourceMap = false, adapterOptions}, done) {\n    const adapter = this.findAdapter(source, mediaType, 'parse');\n\n    if (!adapter) {\n      return done(new Error('Document did not match any registered parsers!'));\n    }\n\n    try {\n      let options = {generateSourceMap, minim, source};\n\n      if (adapterOptions) {\n        options = Object.assign(options, adapterOptions);\n      }\n\n      adapter.parse(options, (err, elements) => {\n        if (!elements) {\n          done(err);\n        } else if (elements instanceof minim.BaseElement) {\n          done(err, elements);\n        } else {\n          done(err, this.load(elements));\n        }\n      });\n    } catch (err) {\n      return done(err);\n    }\n  }\n\n  /*\n   * Serialize a parsed API into the given output format.\n   */\n  serialize({api, mediaType = 'text/vnd.apiblueprint'}, done) {\n    const adapter = findAdapter(this.adapters, mediaType, 'serialize');\n\n    if (adapter) {\n      try {\n        adapter.serialize({api, minim}, done);\n      } catch (err) {\n        return done(err);\n      }\n    } else {\n      done(new Error('Media type did not match any registered serializer!'));\n    }\n  }\n}\n\n/*\n  Since we need to provide a sane interface to both ES6 `import` and\n  normal Node.js `require` statements, we make a single default export\n  and set up some other faux exports within it. See Babel's module\n  docs: https://babeljs.io/docs/usage/modules/.\n*/\nconst fury = new Fury();\n\nfury.Fury = Fury;\n\nexport default fury;\n"]}