// Generated by CoffeeScript 1.12.4
var EventEmitter, HooksWorkerClient, crossSpawn, generateUuid, logger, net, spawnArgs, which,
  hasProp = {}.hasOwnProperty;

net = require('net');

EventEmitter = require('events').EventEmitter;

crossSpawn = require('cross-spawn');

spawnArgs = require('spawn-args');

generateUuid = require('uuid').v4;

logger = require('./logger');

which = require('./which');

HooksWorkerClient = (function() {
  function HooksWorkerClient(runner) {
    var options;
    this.runner = runner;
    options = this.runner.hooks.configuration.options;
    this.language = options.language;
    this.timeout = options['hooks-worker-timeout'] || 5000;
    this.connectTimeout = options['hooks-worker-connect-timeout'] || 1500;
    this.connectRetry = options['hooks-worker-connect-retry'] || 500;
    this.afterConnectWait = options['hooks-worker-after-connect-wait'] || 100;
    this.termTimeout = options['hooks-worker-term-timeout'] || 5000;
    this.termRetry = options['hooks-worker-term-retry'] || 500;
    this.handlerHost = options['hooks-worker-handler-host'] || '127.0.0.1';
    this.handlerPort = options['hooks-worker-handler-port'] || 61321;
    this.handlerMessageDelimiter = '\n';
    this.clientConnected = false;
    this.handlerEnded = false;
    this.handlerKilledIntentionally = false;
    this.connectError = false;
    this.emitter = new EventEmitter;
  }

  HooksWorkerClient.prototype.start = function(callback) {
    logger.verbose('Looking up hooks handler implementation:', this.language);
    return this.setCommandAndCheckForExecutables((function(_this) {
      return function(executablesError) {
        if (executablesError) {
          return callback(executablesError);
        }
        logger.verbose('Starting hooks handler.');
        return _this.spawnHandler(function(spawnHandlerError) {
          if (spawnHandlerError) {
            return callback(spawnHandlerError);
          }
          logger.verbose('Connecting to hooks handler.');
          return _this.connectToHandler(function(connectHandlerError) {
            if (connectHandlerError) {
              return callback(connectHandlerError);
            }
            logger.verbose('Registering hooks.');
            return _this.registerHooks(function(registerHooksError) {
              if (registerHooksError) {
                return callback(registerHooksError);
              }
              return callback();
            });
          });
        });
      };
    })(this));
  };

  HooksWorkerClient.prototype.stop = function(callback) {
    this.disconnectFromHandler();
    return this.terminateHandler(callback);
  };

  HooksWorkerClient.prototype.terminateHandler = function(callback) {
    var kill, start, term, timeout, waitForHandlerTermOrKill;
    logger.verbose('Terminating hooks handler process.');
    term = (function(_this) {
      return function() {
        logger.info('Gracefully terminating hooks handler process.');
        _this.handlerKilledIntentionally = true;
        return _this.handler.kill('SIGTERM');
      };
    })(this);
    kill = (function(_this) {
      return function() {
        logger.info('Killing hooks handler process');
        return _this.handler.kill('SIGKILL');
      };
    })(this);
    start = Date.now();
    term();
    waitForHandlerTermOrKill = (function(_this) {
      return function() {
        var timeout;
        if (_this.handlerEnded === true) {
          clearTimeout(timeout);
          logger.debug('Hooks handler process successfully terminated.');
          return callback();
        } else {
          logger.debug('Hooks handler process haven\'t terminated yet.');
          if ((Date.now() - start) < _this.termTimeout) {
            term();
            return timeout = setTimeout(waitForHandlerTermOrKill, _this.termRetry);
          } else {
            kill();
            clearTimeout(timeout);
            return callback();
          }
        }
      };
    })(this);
    return timeout = setTimeout(waitForHandlerTermOrKill, this.termRetry);
  };

  HooksWorkerClient.prototype.disconnectFromHandler = function() {
    return this.handlerClient.destroy();
  };

  HooksWorkerClient.prototype.setCommandAndCheckForExecutables = function(callback) {
    var gopath, msg, parsedArgs;
    if (this.language === 'ruby') {
      this.handlerCommand = 'dredd-hooks-ruby';
      this.handlerCommandArgs = [];
      if (!which.which(this.handlerCommand)) {
        msg = "Ruby hooks handler command not found: " + this.handlerCommand + "\nInstall ruby hooks handler by running:\n$ gem install dredd_hooks";
        return callback(new Error(msg));
      } else {
        return callback();
      }
    } else if (this.language === 'python') {
      this.handlerCommand = 'dredd-hooks-python';
      this.handlerCommandArgs = [];
      if (!which.which(this.handlerCommand)) {
        msg = "Python hooks handler command not found: " + this.handlerCommand + "\nInstall python hooks handler by running:\n$ pip install dredd_hooks";
        return callback(new Error(msg));
      } else {
        return callback();
      }
    } else if (this.language === 'php') {
      this.handlerCommand = 'dredd-hooks-php';
      this.handlerCommandArgs = [];
      if (!which.which(this.handlerCommand)) {
        msg = "PHP hooks handler command not found: " + this.handlerCommand + "\nInstall php hooks handler by running:\n$ composer require ddelnano/dredd-hooks-php --dev";
        return callback(new Error(msg));
      } else {
        return callback();
      }
    } else if (this.language === 'perl') {
      this.handlerCommand = 'dredd-hooks-perl';
      this.handlerCommandArgs = [];
      if (!which.which(this.handlerCommand)) {
        msg = "Perl hooks handler command not found: " + this.handlerCommand + "\nInstall perl hooks handler by running:\n$ cpanm Dredd::Hooks";
        return callback(new Error(msg));
      } else {
        return callback();
      }
    } else if (this.language === 'nodejs') {
      msg = 'Hooks handler should not be used for Node.js. Use Dredd\'s native Node.js hooks instead.';
      return callback(new Error(msg));
    } else if (this.language === 'go') {
      gopath = process.env.GOPATH;
      this.handlerCommand = gopath + "/bin/goodman";
      this.handlerCommandArgs = [];
      if (!which.which(this.handlerCommand)) {
        msg = 'Go hooks handler command not found in $GOPATH/bin\nInstall go hooks handler by running:\n$ go get github.com/snikch/goodman/cmd/goodman';
        return callback(new Error(msg));
      } else {
        return callback();
      }
    } else {
      parsedArgs = spawnArgs(this.language);
      this.handlerCommand = parsedArgs.shift();
      this.handlerCommandArgs = parsedArgs;
      logger.verbose("Using '" + this.handlerCommand + "' as a hook handler command, '" + (this.handlerCommandArgs.join(' ')) + "' as arguments");
      if (!which.which(this.handlerCommand)) {
        msg = "Hooks handler command not found: " + this.handlerCommand;
        return callback(new Error(msg));
      } else {
        return callback();
      }
    }
  };

  HooksWorkerClient.prototype.spawnHandler = function(callback) {
    var handlerCommandArgs, pathGlobs, ref, ref1, ref2;
    pathGlobs = [].concat((ref = this.runner.hooks) != null ? (ref1 = ref.configuration) != null ? (ref2 = ref1.options) != null ? ref2.hookfiles : void 0 : void 0 : void 0);
    handlerCommandArgs = this.handlerCommandArgs.concat(pathGlobs);
    logger.info("Spawning `" + this.language + "` hooks handler process.");
    this.handler = crossSpawn.spawn(this.handlerCommand, handlerCommandArgs);
    this.handler.stdout.on('data', function(data) {
      return logger.info("Hooks handler stdout:", data.toString());
    });
    this.handler.stderr.on('data', function(data) {
      return logger.info("Hooks handler stderr:", data.toString());
    });
    this.handler.on('exit', (function(_this) {
      return function(status) {
        var msg;
        if (status != null) {
          if (status !== 0) {
            msg = "Hooks handler process '" + _this.handlerCommand + "' exited with status: " + status;
            logger.error(msg);
            _this.runner.hookHandlerError = new Error(msg);
          }
        } else {
          if (!_this.handlerKilledIntentionally) {
            msg = "Hooks handler process '" + _this.handlerCommand + "' was killed.";
            logger.error(msg);
            _this.runner.hookHandlerError = new Error(msg);
          }
        }
        return _this.handlerEnded = true;
      };
    })(this));
    this.handler.on('error', (function(_this) {
      return function(error) {
        _this.runner.hookHandlerError = error;
        return _this.handlerEnded = true;
      };
    })(this));
    return callback();
  };

  HooksWorkerClient.prototype.connectToHandler = function(callback) {
    var connectAndSetupClient, start, timeout, waitForConnect;
    start = Date.now();
    waitForConnect = (function(_this) {
      return function() {
        var error, msg, timeout;
        if ((Date.now() - start) < _this.connectTimeout) {
          clearTimeout(timeout);
          if (_this.connectError !== false) {
            logger.warn('Error connecting to the hooks handler process. Is the handler running? Retrying.');
            _this.connectError = false;
          }
          if (_this.clientConnected !== true) {
            connectAndSetupClient();
            return timeout = setTimeout(waitForConnect, _this.connectRetry);
          }
        } else {
          clearTimeout(timeout);
          if (!_this.clientConnected) {
            if (_this.handlerClient != null) {
              _this.handlerClient.destroy();
            }
            msg = ("Connection timeout " + (_this.connectTimeout / 1000) + "s to hooks handler ") + ("on " + _this.handlerHost + ":" + _this.handlerPort + " exceeded. Try increasing the limit.");
            error = new Error(msg);
            return callback(error);
          }
        }
      };
    })(this);
    connectAndSetupClient = (function(_this) {
      return function() {
        var handlerBuffer;
        logger.verbose('Starting TCP connection with hooks handler process.');
        if (_this.runner.hookHandlerError != null) {
          return callback(_this.runner.hookHandlerError);
        }
        _this.handlerClient = net.connect({
          port: _this.handlerPort,
          host: _this.handlerHost
        });
        _this.handlerClient.on('connect', function() {
          logger.info("Successfully connected to hooks handler. Waiting " + (_this.afterConnectWait / 1000) + "s to start testing.");
          _this.clientConnected = true;
          clearTimeout(timeout);
          return setTimeout(callback, _this.afterConnectWait);
        });
        _this.handlerClient.on('close', function() {
          return logger.debug('TCP communication with hooks handler closed.');
        });
        _this.handlerClient.on('error', function(connectError) {
          logger.debug('TCP communication with hooks handler errored.', connectError);
          return _this.connectError = connectError;
        });
        handlerBuffer = '';
        return _this.handlerClient.on('data', function(data) {
          var i, j, len, len1, message, messages, results, splittedData;
          logger.debug('Dredd received some data from hooks handler.');
          handlerBuffer += data.toString();
          if (data.toString().indexOf(_this.handlerMessageDelimiter) > -1) {
            splittedData = handlerBuffer.split(_this.handlerMessageDelimiter);
            handlerBuffer = splittedData.pop();
            messages = [];
            for (i = 0, len = splittedData.length; i < len; i++) {
              message = splittedData[i];
              messages.push(JSON.parse(message));
            }
            results = [];
            for (j = 0, len1 = messages.length; j < len1; j++) {
              message = messages[j];
              if (message.uuid != null) {
                logger.verbose('Dredd received a valid message from hooks handler:', message.uuid);
                results.push(_this.emitter.emit(message.uuid, message));
              } else {
                results.push(logger.verbose('UUID not present in hooks handler message, ignoring:', JSON.stringify(message, null, 2)));
              }
            }
            return results;
          }
        });
      };
    })(this);
    return timeout = setTimeout(waitForConnect, this.connectRetry);
  };

  HooksWorkerClient.prototype.registerHooks = function(callback) {
    var eachHookNames, eventName, fn, i, len;
    eachHookNames = ['beforeEach', 'beforeEachValidation', 'afterEach', 'beforeAll', 'afterAll'];
    fn = (function(_this) {
      return function(eventName) {
        return _this.runner.hooks[eventName](function(data, hookCallback) {
          var handleTimeout, message, messageHandler, timeout, uuid;
          uuid = generateUuid();
          message = {
            event: eventName,
            uuid: uuid,
            data: data
          };
          logger.verbose('Sending HTTP transaction data to hooks handler:', uuid);
          _this.handlerClient.write(JSON.stringify(message));
          _this.handlerClient.write(_this.handlerMessageDelimiter);
          messageHandler = function(receivedMessage) {
            var index, j, key, len1, ref, ref1, value;
            logger.verbose('Handling hook:', uuid);
            clearTimeout(timeout);
            if (eventName.indexOf('All') > -1) {
              ref = receivedMessage.data;
              for (index = j = 0, len1 = ref.length; j < len1; index = ++j) {
                value = ref[index];
                data[index] = value;
              }
            } else {
              ref1 = receivedMessage.data;
              for (key in ref1) {
                if (!hasProp.call(ref1, key)) continue;
                value = ref1[key];
                data[key] = value;
              }
            }
            return hookCallback();
          };
          handleTimeout = function() {
            logger.warn('Hook handling timed out.');
            if (eventName.indexOf('All') === -1) {
              data.fail = 'Hook timed out.';
            }
            _this.emitter.removeListener(uuid, messageHandler);
            return hookCallback();
          };
          timeout = setTimeout(handleTimeout, _this.timeout);
          return _this.emitter.on(uuid, messageHandler);
        });
      };
    })(this);
    for (i = 0, len = eachHookNames.length; i < len; i++) {
      eventName = eachHookNames[i];
      fn(eventName);
    }
    this.runner.hooks.afterAll((function(_this) {
      return function(transactions, hookCallback) {
        var index, j, len1, modification, modifications, ref;
        if (process.env.TEST_DREDD_HOOKS_HANDLER_ORDER === 'true') {
          console.error('FOR TESTING ONLY');
          modifications = ((ref = transactions[0]) != null ? ref.hooks_modifications : void 0) || [];
          if (!modifications.length) {
            throw new Error('Hooks must modify transaction.hooks_modifications');
          }
          for (index = j = 0, len1 = modifications.length; j < len1; index = ++j) {
            modification = modifications[index];
            console.error(index + " " + modification);
          }
          console.error('FOR TESTING ONLY');
        }
        return _this.stop(hookCallback);
      };
    })(this));
    return callback();
  };

  return HooksWorkerClient;

})();

module.exports = HooksWorkerClient;
