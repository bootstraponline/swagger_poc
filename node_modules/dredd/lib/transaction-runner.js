// Generated by CoffeeScript 1.12.4
var Pitboss, TransactionRunner, addHooks, async, chai, clone, flattenHeaders, gavel, logger, os, packageData, path, requestLib, sandboxedLogLibraryPath, sortTransactions, url,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  hasProp = {}.hasOwnProperty;

requestLib = require('request');

url = require('url');

path = require('path');

os = require('os');

chai = require('chai');

gavel = require('gavel');

async = require('async');

clone = require('clone');

Pitboss = require('pitboss-ng').Pitboss;

flattenHeaders = require('./flatten-headers');

addHooks = require('./add-hooks');

sortTransactions = require('./sort-transactions');

packageData = require('./../package.json');

logger = require('./logger');

sandboxedLogLibraryPath = '../../../lib/hooks-log-sandboxed';

TransactionRunner = (function() {
  function TransactionRunner(configuration1) {
    this.configuration = configuration1;
    this.executeTransaction = bind(this.executeTransaction, this);
    this.configureTransaction = bind(this.configureTransaction, this);
    this.logs = [];
    this.hookStash = {};
    this.error = null;
    this.hookHandlerError = null;
  }

  TransactionRunner.prototype.config = function(config) {
    this.configuration = config;
    return this.multiBlueprint = Object.keys(this.configuration.data).length > 1;
  };

  TransactionRunner.prototype.run = function(transactions, callback) {
    logger.verbose('Sorting HTTP transactions');
    transactions = this.configuration.options['sorted'] ? sortTransactions(transactions) : transactions;
    logger.verbose('Configuring HTTP transactions');
    return async.mapSeries(transactions, this.configureTransaction.bind(this), (function(_this) {
      return function(err, results) {
        transactions = results;
        logger.verbose('Reading hook files and registering hooks');
        return addHooks(_this, transactions, function(addHooksError) {
          if (addHooksError) {
            return callback(addHooksError);
          }
          logger.verbose('Executing HTTP transactions');
          return _this.executeAllTransactions(transactions, _this.hooks, callback);
        });
      };
    })(this));
  };

  TransactionRunner.prototype.executeAllTransactions = function(transactions, hooks, callback) {
    var i, len, transaction;
    if (!hooks.transactions) {
      hooks.transactions = {};
      for (i = 0, len = transactions.length; i < len; i++) {
        transaction = transactions[i];
        hooks.transactions[transaction.name] = transaction;
      }
    }
    if (this.hookHandlerError) {
      return callback(this.hookHandlerError);
    }
    logger.verbose('Running \'beforeAll\' hooks');
    return this.runHooksForData(hooks.beforeAllHooks, transactions, true, (function(_this) {
      return function() {
        if (_this.hookHandlerError) {
          return callback(_this.hookHandlerError);
        }
        return async.timesSeries(transactions.length, function(transactionIndex, iterationCallback) {
          transaction = transactions[transactionIndex];
          logger.verbose("Processing transaction #" + (transactionIndex + 1) + ":", transaction.name);
          logger.verbose('Running \'beforeEach\' hooks');
          return _this.runHooksForData(hooks.beforeEachHooks, transaction, false, function() {
            if (_this.hookHandlerError) {
              return iterationCallback(_this.hookHandlerError);
            }
            logger.verbose('Running \'before\' hooks');
            return _this.runHooksForData(hooks.beforeHooks[transaction.name], transaction, false, function() {
              if (_this.hookHandlerError) {
                return iterationCallback(_this.hookHandlerError);
              }
              return _this.executeTransaction(transaction, hooks, function() {
                if (_this.hookHandlerError) {
                  return iterationCallback(_this.hookHandlerError);
                }
                logger.verbose('Running \'afterEach\' hooks');
                return _this.runHooksForData(hooks.afterEachHooks, transaction, false, function() {
                  if (_this.hookHandlerError) {
                    return iterationCallback(_this.hookHandlerError);
                  }
                  logger.verbose('Running \'after\' hooks');
                  return _this.runHooksForData(hooks.afterHooks[transaction.name], transaction, false, function() {
                    if (_this.hookHandlerError) {
                      return iterationCallback(_this.hookHandlerError);
                    }
                    logger.debug("Evaluating results of transaction execution #" + (transactionIndex + 1) + ":", transaction.name);
                    return _this.emitResult(transaction, iterationCallback);
                  });
                });
              });
            });
          });
        }, function(iterationError) {
          if (iterationError) {
            return callback(iterationError);
          }
          logger.verbose('Running \'afterAll\' hooks');
          return _this.runHooksForData(hooks.afterAllHooks, transactions, true, function() {
            if (_this.hookHandlerError) {
              return callback(_this.hookHandlerError);
            }
            return callback();
          });
        });
      };
    })(this));
  };

  TransactionRunner.prototype.runHooksForData = function(hooks, data, legacy, callback) {
    var runHookWithData;
    if (legacy == null) {
      legacy = false;
    }
    if ((hooks != null) && Array.isArray(hooks)) {
      logger.debug('Running hooks...');
      runHookWithData = (function(_this) {
        return function(hookFnIndex, runHookCallback) {
          var error, hookFn, i, len, transaction, transactions;
          hookFn = hooks[hookFnIndex];
          try {
            if (legacy) {
              return _this.runLegacyHook(hookFn, data, function(err) {
                if (err) {
                  logger.debug('Legacy hook errored:', err);
                  _this.emitHookError(err, data);
                }
                return runHookCallback();
              });
            } else {
              return _this.runHook(hookFn, data, function(err) {
                if (err) {
                  logger.debug('Hook errored:', err);
                  _this.emitHookError(err, data);
                }
                return runHookCallback();
              });
            }
          } catch (error1) {
            error = error1;
            if (error instanceof chai.AssertionError) {
              transactions = Array.isArray(data) ? data : [data];
              for (i = 0, len = transactions.length; i < len; i++) {
                transaction = transactions[i];
                _this.failTransaction(transaction, "Failed assertion in hooks: " + error.message);
              }
            } else {
              logger.debug('Hook errored:', error);
              _this.emitHookError(error, data);
            }
            return runHookCallback();
          }
        };
      })(this);
      return async.timesSeries(hooks.length, runHookWithData, function() {
        return callback();
      });
    } else {
      return callback();
    }
  };

  TransactionRunner.prototype.emitHookError = function(error, data) {
    var test;
    if (!(error instanceof Error)) {
      error = new Error(error);
    }
    test = this.createTest(data);
    test.request = data.request;
    return this.emitError(error, test);
  };

  TransactionRunner.prototype.sandboxedHookResultsHandler = function(err, data, results, callback) {
    var i, key, len, log, ref, ref1, value;
    if (results == null) {
      results = {};
    }
    if (err) {
      return callback(err);
    }
    ref = results.data || {};
    for (key in ref) {
      value = ref[key];
      data[key] = value;
    }
    this.hookStash = results.stash;
    if (this.logs == null) {
      this.logs = [];
    }
    ref1 = results.logs || [];
    for (i = 0, len = ref1.length; i < len; i++) {
      log = ref1[i];
      this.logs.push(log);
    }
    callback();
  };

  TransactionRunner.prototype.sandboxedWrappedCode = function(hookCode) {
    return "// run the hook\nvar log = _log.bind(null, _logs);\n\nvar _func = " + hookCode + ";\n_func(_data);\n\n// setup the return object\nvar output = {};\noutput[\"data\"] = _data;\noutput[\"stash\"] = stash;\noutput[\"logs\"] = _logs;\noutput;";
  };

  TransactionRunner.prototype.runSandboxedHookFromString = function(hookString, data, callback) {
    var sandbox, wrappedCode;
    wrappedCode = this.sandboxedWrappedCode(hookString);
    sandbox = new Pitboss(wrappedCode, {
      timeout: 500
    });
    return sandbox.run({
      context: {
        '_data': data,
        '_logs': [],
        'stash': this.hookStash
      },
      libraries: {
        '_log': sandboxedLogLibraryPath
      }
    }, (function(_this) {
      return function(err, result) {
        if (result == null) {
          result = {};
        }
        sandbox.kill();
        return _this.sandboxedHookResultsHandler(err, data, result, callback);
      };
    })(this));
  };

  TransactionRunner.prototype.runLegacyHook = function(hook, data, callback) {
    if (typeof hook === 'function') {
      if (hook.length === 1) {
        logger.warn('DEPRECATION WARNING!\n\nYou are using only one argument for the `beforeAll` or `afterAll` hook function.\nOne argument hook functions will be treated as synchronous in the near future.\nTo keep the async behaviour, just define hook function with two parameters.\n\nInterface of the hooks functions will be unified soon across all hook functions:\n\n - `beforeAll` and `afterAll` hooks will support sync API depending on number of arguments\n - Signatures of callbacks of all hooks will be the same\n - First passed argument will be a `transactions` object\n - Second passed argument will be a optional callback function for async\n - `transactions` object in `hooks` module object will be removed\n - Manipulation with transaction data will have to be performed on the first function argument');
        hook(callback);
      } else if (hook.length === 2) {
        hook(data, function() {
          return callback();
        });
      }
    }
    if (typeof hook === 'string') {
      return this.runSandboxedHookFromString(hook, data, callback);
    }
  };

  TransactionRunner.prototype.runHook = function(hook, data, callback) {
    if (typeof hook === 'function') {
      if (hook.length === 1) {
        hook(data);
        callback();
      } else if (hook.length === 2) {
        hook(data, function() {
          return callback();
        });
      }
    }
    if (typeof hook === 'string') {
      return this.runSandboxedHookFromString(hook, data, callback);
    }
  };

  TransactionRunner.prototype.configureTransaction = function(transaction, callback) {
    var configuration, configuredTransaction, expected, flatHeaders, fullPath, header, headerKey, headerValue, i, len, mediaType, origin, ref, ref1, request, response, skip, splitIndex, status, system;
    configuration = this.configuration;
    origin = transaction.origin, request = transaction.request, response = transaction.response;
    mediaType = ((ref = configuration.data[origin.filename]) != null ? ref.mediaType : void 0) || 'text/vnd.apiblueprint';
    if (this.parsedUrl == null) {
      this.parsedUrl = this.parseServerUrl(configuration.server);
    }
    fullPath = this.getFullPath(this.parsedUrl.path, request.uri);
    flatHeaders = flattenHeaders(request['headers']);
    if (!flatHeaders['User-Agent']) {
      system = os.type() + ' ' + os.release() + '; ' + os.arch();
      flatHeaders['User-Agent'] = "Dredd/" + packageData.version + " (" + system + ")";
    }
    if (configuration.options.header.length > 0) {
      ref1 = configuration.options.header;
      for (i = 0, len = ref1.length; i < len; i++) {
        header = ref1[i];
        splitIndex = header.indexOf(':');
        headerKey = header.substring(0, splitIndex);
        headerValue = header.substring(splitIndex + 1);
        flatHeaders[headerKey] = headerValue;
      }
    }
    request['headers'] = flatHeaders;
    expected = {
      headers: flattenHeaders(response['headers']),
      body: response['body'],
      statusCode: response['status']
    };
    if (response['schema']) {
      expected['bodySchema'] = response['schema'];
    }
    if (!this.multiBlueprint) {
      transaction.name = transaction.name.replace(transaction.origin.apiName + " > ", "");
    }
    skip = false;
    if (mediaType.indexOf('swagger') !== -1) {
      status = parseInt(response.status, 10);
      if (status < 200 || status >= 300) {
        skip = true;
      }
    }
    configuredTransaction = {
      name: transaction.name,
      id: request.method + ' ' + request.uri,
      host: this.parsedUrl.hostname,
      port: this.parsedUrl.port,
      request: request,
      expected: expected,
      origin: origin,
      fullPath: fullPath,
      protocol: this.parsedUrl.protocol,
      skip: skip
    };
    return callback(null, configuredTransaction);
  };

  TransactionRunner.prototype.parseServerUrl = function(serverUrl) {
    if (!serverUrl.match(/^https?:\/\//i)) {
      serverUrl = 'http://' + serverUrl.replace(/^[:\/]*/, '');
    }
    return url.parse(serverUrl);
  };

  TransactionRunner.prototype.getFullPath = function(serverPath, requestPath) {
    var segment, segments, trailingSlash;
    if (serverPath === '/') {
      return requestPath;
    }
    if (!requestPath) {
      return serverPath;
    }
    segments = [serverPath, requestPath];
    segments = (function() {
      var i, len, results1;
      results1 = [];
      for (i = 0, len = segments.length; i < len; i++) {
        segment = segments[i];
        results1.push(segment.replace(/^\/|\/$/g, ''));
      }
      return results1;
    })();
    trailingSlash = requestPath !== '/' && requestPath.slice(-1) === '/' ? '/' : '';
    return '/' + segments.join('/') + trailingSlash;
  };

  TransactionRunner.prototype.createTest = function(transaction) {
    return {
      status: '',
      title: transaction.id,
      message: transaction.name,
      origin: transaction.origin,
      startedAt: transaction.startedAt
    };
  };

  TransactionRunner.prototype.failTransaction = function(transaction, reason) {
    var base;
    transaction.fail = true;
    this.ensureTransactionResultsGeneralSection(transaction);
    if (reason) {
      transaction.results.general.results.push({
        severity: 'error',
        message: reason
      });
    }
    if (transaction.test == null) {
      transaction.test = this.createTest(transaction);
    }
    transaction.test.status = 'fail';
    if (reason) {
      transaction.test.message = reason;
    }
    return (base = transaction.test).results != null ? base.results : base.results = transaction.results;
  };

  TransactionRunner.prototype.skipTransaction = function(transaction, reason) {
    var base;
    transaction.skip = true;
    this.ensureTransactionResultsGeneralSection(transaction);
    if (reason) {
      transaction.results.general.results.push({
        severity: 'warning',
        message: reason
      });
    }
    if (transaction.test == null) {
      transaction.test = this.createTest(transaction);
    }
    transaction.test.status = 'skip';
    if (reason) {
      transaction.test.message = reason;
    }
    return (base = transaction.test).results != null ? base.results : base.results = transaction.results;
  };

  TransactionRunner.prototype.ensureTransactionResultsGeneralSection = function(transaction) {
    var base, base1;
    if (transaction.results == null) {
      transaction.results = {};
    }
    if ((base = transaction.results).general == null) {
      base.general = {};
    }
    return (base1 = transaction.results.general).results != null ? base1.results : base1.results = [];
  };

  TransactionRunner.prototype.emitResult = function(transaction, callback) {
    if (this.error || !transaction.test) {
      logger.debug('No emission of test data to reporters', this.error, transaction.test);
      this.error = null;
      return callback();
    }
    if (transaction.skip) {
      logger.debug('Emitting to reporters: test skip');
      this.configuration.emitter.emit('test skip', transaction.test, function() {});
      return callback();
    }
    if (transaction.test.valid) {
      if (transaction.fail) {
        this.failTransaction(transaction, "Failed in after hook: " + transaction.fail);
        logger.debug('Emitting to reporters: test fail');
        this.configuration.emitter.emit('test fail', transaction.test, function() {});
      } else {
        logger.debug('Emitting to reporters: test pass');
        this.configuration.emitter.emit('test pass', transaction.test, function() {});
      }
      return callback();
    }
    logger.debug('Emitting to reporters: test fail');
    this.configuration.emitter.emit('test fail', transaction.test, function() {});
    return callback();
  };

  TransactionRunner.prototype.emitError = function(error, test) {
    logger.debug('Emitting to reporters: test error');
    this.configuration.emitter.emit('test error', error, test, function() {});
    return this.error = this.error || error;
  };

  TransactionRunner.prototype.getRequestOptionsFromTransaction = function(transaction) {
    var urlObject;
    urlObject = {
      protocol: transaction.protocol,
      hostname: transaction.host,
      port: transaction.port
    };
    return {
      uri: url.format(urlObject) + transaction.fullPath,
      method: transaction.request.method,
      headers: transaction.request.headers,
      body: transaction.request.body
    };
  };

  TransactionRunner.prototype.setContentLength = function(transaction) {
    var caseInsensitiveRequestHeadersMap, key, ref, value;
    caseInsensitiveRequestHeadersMap = {};
    ref = transaction.request.headers;
    for (key in ref) {
      value = ref[key];
      caseInsensitiveRequestHeadersMap[key.toLowerCase()] = key;
    }
    if (!caseInsensitiveRequestHeadersMap['content-length'] && transaction.request['body'] !== '') {
      logger.verbose('Calculating Content-Length of the request body');
      return transaction.request.headers['Content-Length'] = Buffer.byteLength(transaction.request['body'], 'utf8');
    }
  };

  TransactionRunner.prototype.executeTransaction = function(transaction, hooks, callback) {
    var m, ref, ref1, ref2, test;
    if (!callback) {
      ref = [hooks, void 0], callback = ref[0], hooks = ref[1];
    }
    this.setContentLength(transaction);
    transaction.startedAt = Date.now();
    test = this.createTest(transaction);
    logger.debug('Emitting to reporters: test start');
    this.configuration.emitter.emit('test start', test, function() {});
    this.ensureTransactionResultsGeneralSection(transaction);
    if (transaction.skip) {
      logger.verbose('HTTP transaction was marked in hooks as to be skipped. Skipping');
      transaction.test = test;
      this.skipTransaction(transaction, 'Skipped in before hook');
      return callback();
    } else if (transaction.fail) {
      logger.verbose('HTTP transaction was marked in hooks as to be failed. Reporting as failed');
      transaction.test = test;
      this.failTransaction(transaction, "Failed in before hook: " + transaction.fail);
      return callback();
    } else if (this.configuration.options['dry-run']) {
      logger.info('Dry run. Not performing HTTP request');
      transaction.test = test;
      this.skipTransaction(transaction);
      return callback();
    } else if (this.configuration.options.names) {
      logger.info(transaction.name);
      transaction.test = test;
      this.skipTransaction(transaction);
      return callback();
    } else if (this.configuration.options.method.length > 0 && !(ref1 = transaction.request.method, indexOf.call(this.configuration.options.method, ref1) >= 0)) {
      logger.info("Only " + (((function() {
        var i, len, ref2, results1;
        ref2 = this.configuration.options.method;
        results1 = [];
        for (i = 0, len = ref2.length; i < len; i++) {
          m = ref2[i];
          results1.push(m.toUpperCase());
        }
        return results1;
      }).call(this)).join(', ')) + "requests are set to be executed. Not performing HTTP " + (transaction.request.method.toUpperCase()) + " request.");
      transaction.test = test;
      this.skipTransaction(transaction);
      return callback();
    } else if (this.configuration.options.only.length > 0 && !(ref2 = transaction.name, indexOf.call(this.configuration.options.only, ref2) >= 0)) {
      logger.info("Only '" + this.configuration.options.only + "' transaction is set to be executed. Not performing HTTP request for '" + transaction.name + "'.");
      transaction.test = test;
      this.skipTransaction(transaction);
      return callback();
    } else {
      return this.performRequestAndValidate(test, transaction, hooks, callback);
    }
  };

  TransactionRunner.prototype.performRequestAndValidate = function(test, transaction, hooks, callback) {
    var error, handleRequest, requestOptions;
    requestOptions = this.getRequestOptionsFromTransaction(transaction);
    handleRequest = (function(_this) {
      return function(err, res, body) {
        var real;
        if (err) {
          logger.debug('Requesting tested server errored:', err);
          test.title = transaction.id;
          test.expected = transaction.expected;
          test.request = transaction.request;
          _this.emitError(err, test);
          return callback();
        }
        logger.verbose('Handling HTTP response from tested server');
        real = {
          statusCode: res.statusCode,
          headers: res.headers,
          body: body
        };
        transaction['real'] = real;
        logger.verbose('Running \'beforeEachValidation\' hooks');
        return _this.runHooksForData(hooks != null ? hooks.beforeEachValidationHooks : void 0, transaction, false, function() {
          if (_this.hookHandlerError) {
            return callback(_this.hookHandlerError);
          }
          logger.verbose('Running \'beforeValidation\' hooks');
          return _this.runHooksForData(hooks != null ? hooks.beforeValidationHooks[transaction.name] : void 0, transaction, false, function() {
            if (_this.hookHandlerError) {
              return callback(_this.hookHandlerError);
            }
            return _this.validateTransaction(test, transaction, callback);
          });
        });
      };
    })(this);
    if (transaction.request['body'] && this.isMultipart(requestOptions)) {
      this.replaceLineFeedInBody(transaction, requestOptions);
    }
    logger.verbose("About to perform " + (transaction.protocol.slice(0, -1).toUpperCase()) + " request to tested server: " + requestOptions.method + " " + requestOptions.uri);
    try {
      return this.performRequest(requestOptions, handleRequest);
    } catch (error1) {
      error = error1;
      logger.debug('Requesting tested server errored:', error);
      test.title = transaction.id;
      test.expected = transaction.expected;
      test.request = transaction.request;
      this.emitError(error, test);
      return callback();
    }
  };

  TransactionRunner.prototype.performRequest = function(options, callback) {
    return requestLib(options, callback);
  };

  TransactionRunner.prototype.validateTransaction = function(test, transaction, callback) {
    var configuration;
    configuration = this.configuration;
    logger.verbose('Validating HTTP transaction by Gavel.js');
    logger.debug('Determining whether HTTP transaction is valid (getting boolean verdict)');
    return gavel.isValid(transaction.real, transaction.expected, 'response', function(isValidError, isValid) {
      if (isValidError) {
        logger.debug('Gavel.js validation errored:', isValidError);
        this.emitError(isValidError, test);
      }
      test.title = transaction.id;
      test.actual = transaction.real;
      test.expected = transaction.expected;
      test.request = transaction.request;
      if (isValid) {
        test.status = 'pass';
      } else {
        test.status = 'fail';
      }
      logger.debug('Validating HTTP transaction (getting verbose validation result)');
      return gavel.validate(transaction.real, transaction.expected, 'response', function(validateError, gavelResult) {
        var gavelError, i, len, message, rawValidatorOutput, ref, ref1, results, sectionName, validatorOutput;
        if (!isValidError && validateError) {
          logger.debug('Gavel.js validation errored:', validateError);
          this.emitError(validateError, test);
        }
        message = '';
        ref = gavelResult || {};
        for (sectionName in ref) {
          if (!hasProp.call(ref, sectionName)) continue;
          validatorOutput = ref[sectionName];
          if (sectionName !== 'version') {
            ref1 = validatorOutput.results || [];
            for (i = 0, len = ref1.length; i < len; i++) {
              gavelError = ref1[i];
              message += sectionName + ": " + gavelError.message + "\n";
            }
          }
        }
        test.message = message;
        results = transaction.results || {};
        for (sectionName in gavelResult) {
          if (!hasProp.call(gavelResult, sectionName)) continue;
          rawValidatorOutput = gavelResult[sectionName];
          if (!(sectionName !== 'version')) {
            continue;
          }
          if (results[sectionName] == null) {
            results[sectionName] = {};
          }
          validatorOutput = clone(rawValidatorOutput);
          if (results[sectionName].results) {
            validatorOutput.results = validatorOutput.results.concat(results[sectionName].results);
          }
          results[sectionName] = validatorOutput;
        }
        transaction.results = results;
        test.results = transaction.results;
        test.valid = isValid;
        transaction.test = test;
        return callback();
      });
    });
  };

  TransactionRunner.prototype.isMultipart = function(requestOptions) {
    var caseInsensitiveRequestHeaders, key, ref, ref1, value;
    caseInsensitiveRequestHeaders = {};
    ref = requestOptions.headers;
    for (key in ref) {
      value = ref[key];
      caseInsensitiveRequestHeaders[key.toLowerCase()] = value;
    }
    return ((ref1 = caseInsensitiveRequestHeaders['content-type']) != null ? ref1.indexOf("multipart") : void 0) > -1;
  };

  TransactionRunner.prototype.replaceLineFeedInBody = function(transaction, requestOptions) {
    if (transaction.request['body'].indexOf('\r\n') === -1) {
      transaction.request['body'] = transaction.request['body'].replace(/\n/g, '\r\n');
      transaction.request['headers']['Content-Length'] = Buffer.byteLength(transaction.request['body'], 'utf8');
      return requestOptions.headers = transaction.request['headers'];
    }
  };

  return TransactionRunner;

})();

module.exports = TransactionRunner;
