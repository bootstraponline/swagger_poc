{"version":3,"sources":["src/ast.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;sBAGc,QAAQ;;;;sBACF,SAAS;;;;IAER,GAAG;AACX,WADQ,GAAG,CACV,MAAM,EAAE;0BADD,GAAG;;AAEpB,QAAI,CAAC,IAAI,GAAG,oBAAQ,OAAO,CAAC,MAAM,CAAC,CAAC;GACrC;;;;;;;eAHkB,GAAG;;WASX,qBAAC,IAAI,EAAE;AAChB,UAAM,MAAM,GAAG,oBAAE,OAAO,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACnE,UAAI,GAAG,YAAA,CAAC;AACR,UAAI,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;AACrB,UAAI,KAAK,GAAG,MAAM,CAAC,KAAK,EAAE,CAAC;AAC3B,UAAI,KAAK,YAAA,CAAC;;AAEV,UAAI,CAAC,IAAI,EAAE;AACT,eAAO,IAAI,CAAC;OACb;;AAED,aAAO,KAAK,KAAK,SAAS,EAAE;AAC1B,YAAI,OAAO,GAAG,IAAI,CAAC;;AAEnB,YAAI,IAAI,CAAC,GAAG,KAAK,uBAAuB,EAAE;;;;;;;AAExC,8CAAsB,IAAI,CAAC,KAAK,4GAAE;kBAAvB,OAAO;;AAChB,kBAAI,OAAO,CAAC,CAAC,CAAC,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,KAAK,KAAK,EAAE;AAC5C,uBAAO,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;;AAErB,oBAAI,CAAC,MAAM,CAAC,MAAM,EAAE;;AAElB,uBAAK,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,OAAO,CAAC;AACtC,qBAAG,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC;iBACnC;AACD,sBAAM;eACP;aACF;;;;;;;;;;;;;;;SACF,MAAM,IAAI,IAAI,CAAC,GAAG,KAAK,uBAAuB,EAAE;;AAE/C,iBAAO,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;;AAE5B,cAAI,CAAC,MAAM,CAAC,MAAM,EAAE;;;AAGlB,gBAAI,CAAC,OAAO,IAAI,KAAK,GAAG,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC,EAAE;;;AAGlD,mBAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC;AAC/C,iBAAG,GAAG,KAAK,GAAG,CAAC,CAAC;aACjB,MAAM;AACL,mBAAK,GAAG,OAAO,CAAC,UAAU,CAAC,OAAO,CAAC;AACnC,iBAAG,GAAG,OAAO,CAAC,QAAQ,CAAC,OAAO,CAAC;aAChC;WACF;SACF,MAAM;;AAEL,iBAAO,IAAI,CAAC;SACb;;AAED,YAAI,OAAO,EAAE;AACX,cAAI,GAAG,OAAO,CAAC;SAChB,MAAM;;;AAGL,iBAAO,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC;SACnC;;AAED,aAAK,GAAG,MAAM,CAAC,KAAK,EAAE,CAAC;OACxB;;AAED,aAAO,EAAC,KAAK,EAAL,KAAK,EAAE,GAAG,EAAH,GAAG,EAAC,CAAC;KACrB;;;SAvEkB,GAAG;;;qBAAH,GAAG","file":"src/ast.js","sourcesContent":["// A module for dealing with YAML syntax trees and looking up source map\n// location information.\n\nimport _ from 'lodash';\nimport yamlAst from 'yaml-js';\n\nexport default class Ast {\n  constructor(source) {\n    this.root = yamlAst.compose(source);\n  }\n\n  // Look up a position in the original source based on a JSON path, for\n  // example ['paths', '/test', 'get', 'responses', '200']. Also supported\n  // is using a string ('paths./test.get') but it does not understand any\n  // escaping.\n  getPosition(path) {\n    const pieces = _.isArray(path) ? [].concat(path) : path.split('.');\n    let end;\n    let node = this.root;\n    let piece = pieces.shift();\n    let start;\n\n    if (!node) {\n      return null;\n    }\n\n    while (piece !== undefined) {\n      let newNode = null;\n\n      if (node.tag === 'tag:yaml.org,2002:map') {\n        // This is a may / object with key:value pairs.\n        for (const subNode of node.value) {\n          if (subNode[0] && subNode[0].value === piece) {\n            newNode = subNode[1];\n\n            if (!pieces.length) {\n              // This is the last item!\n              start = subNode[0].start_mark.pointer;\n              end = subNode[1].end_mark.pointer;\n            }\n            break;\n          }\n        }\n      } else if (node.tag === 'tag:yaml.org,2002:seq') {\n        // This is a sequence, i.e. array. Access it by index.\n        newNode = node.value[piece];\n\n        if (!pieces.length) {\n          // This is the last item!\n\n          if (!newNode && piece > 0 && node.value[piece - 1]) {\n            // Element in sequence does not exist. It could have been empty\n            // Let's provide the end of previous element\n            start = node.value[piece - 1].end_mark.pointer;\n            end = start + 1;\n          } else {\n            start = newNode.start_mark.pointer;\n            end = newNode.end_mark.pointer;\n          }\n        }\n      } else {\n        // Unknown piece, which will just return no source map.\n        return null;\n      }\n\n      if (newNode) {\n        node = newNode;\n      } else {\n        // We have no other node so return whatever we have.\n        // Better than nothing init?\n        return { start: start, end: end };\n      }\n\n      piece = pieces.shift();\n    }\n\n    return {start, end};\n  }\n}\n"]}